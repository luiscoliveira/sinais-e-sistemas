{"/":{"title":"Sinais e Sistemas 2022-23","content":"\n# Resumos e Problemas\n\n_Luis Caldas de Oliveira_\n\nlco@tecnico.ulisboa.pt\n\n## Semana 1 (2022-11-21)\n- [Aula01](aulas/aula01/Aula01.md)","lastmodified":"2022-11-17T15:36:24.729381102Z","tags":null},"/aulas/aula01/Aula01":{"title":"Aula01","content":"\n\n## Sumário\n\n- Apresentação da unidade curricular de Sinais e Sistemas\n- [1 Sinais e Sistemas](topicos/1%20Sinais%20e%20Sistemas.md)\n- [1-1 Sinais em tempo contínuo e em tempo discreto](topicos/1-1%20Sinais%20em%20tempo%20contínuo%20e%20em%20tempo%20discreto.md)\n- [1-2 Transformação da variável independente](topicos/1-2%20Transformação%20da%20variável%20independente.md)\n\n## Novos conceitos\n\n### [1-1 Sinais em tempo contínuo e em tempo discreto](topicos/1-1%20Sinais%20em%20tempo%20contínuo%20e%20em%20tempo%20discreto.md)\n- [sinal acústico](aulas/aula01/ss-sin-conc/sinal%20acústico.md)\n- [função matemática](aulas/aula01/ss-sin-conc/função%20matemática.md)\n- [conjunto de números](aulas/aula01/ss-sin-conc/conjunto%20de%20números.md)\n- [sinal em tempo contínuo](aulas/aula01/ss-sin-conc/sinal%20em%20tempo%20contínuo.md)\n- [tom puro em tempo contínuo](aulas/aula01/ss-sin-conc/tom%20puro%20em%20tempo%20contínuo.md)\n- [sinal bi-dimensional](aulas/aula01/ss-sin-conc/sinal%20bi-dimensional.md)\n- [sinal em tempo discreto](aulas/aula01/ss-sin-conc/sinal%20em%20tempo%20discreto.md)\n- [valor de fecho de índice de bolsa](aulas/aula01/ss-sin-conc/valor%20de%20fecho%20de%20índice%20de%20bolsa.md)\n- [imagem digital](aulas/aula01/ss-sin-conc/imagem%20digital.md)\n- [video digital](aulas/aula01/ss-sin-conc/video%20digital.md)\n- [amostragem de um sinal em tempo contínuo](aulas/aula01/ss-sin-conc/amostragem%20de%20um%20sinal%20em%20tempo%20contínuo.md)\n- [período de amostragem](aulas/aula01/ss-sin-conc/período%20de%20amostragem.md)\n- [ritmo ou frequência de amostragem](aulas/aula01/ss-sin-conc/ritmo%20ou%20frequência%20de%20amostragem.md)\n- [tom puro em tempo discreto](aulas/aula01/ss-sin-conc/tom%20puro%20em%20tempo%20discreto.md)\n- [codificação da amplitude](aulas/aula01/ss-sin-conc/codificação%20da%20amplitude.md)\n- [energia de um sinal](aulas/aula01/ss-sin-conc/energia%20de%20um%20sinal.md)\n- [potência de um sinal](aulas/aula01/ss-sin-conc/potência%20de%20um%20sinal.md)\n\n### [1-2 Transformação da variável independente](topicos/1-2%20Transformação%20da%20variável%20independente.md)\n- [deslocamento temporal em tempo contínuo](aulas/aula01/ss-tvi-conc/deslocamento%20temporal%20em%20tempo%20contínuo.md)\n- [inversão temporal](aulas/aula01/ss-tvi-conc/inversão%20temporal.md)\n- [escalamento temporal](aulas/aula01/ss-tvi-conc/escalamento%20temporal.md)\n- [sinais pares e ímpares](aulas/aula01/ss-tvi-conc/sinais%20pares%20e%20ímpares.md)\n- [complexo conjugado](aulas/aula01/ss-tvi-conc/complexo%20conjugado.md)\n- [fórmula de Euler](aulas/aula01/ss-tvi-conc/fórmula%20de%20Euler.md)\n- [componente par e ímpar de um sinal](aulas/aula01/ss-tvi-conc/componente%20par%20e%20ímpar%20de%20um%20sinal.md)\n\n\n## Problemas\n\n### [1-1 Sinais em tempo contínuo e em tempo discreto](topicos/1-1%20Sinais%20em%20tempo%20contínuo%20e%20em%20tempo%20discreto.md)\n\n\n### [1-2 Transformação da variável independente](topicos/1-2%20Transformação%20da%20variável%20independente.md)","lastmodified":"2022-11-17T15:36:24.729381102Z","tags":null},"/aulas/aula01/ss-sin-conc/amostragem-de-um-sinal-em-tempo-cont%C3%ADnuo":{"title":"amostragem de um sinal em tempo contínuo","content":"\n\nUm [sinal em tempo discreto](aulas/aula01/ss-sin-conc/sinal%20em%20tempo%20discreto.md) pode ser o resultado da amostragem de um [sinal em tempo contínuo](aulas/aula01/ss-sin-conc/sinal%20em%20tempo%20contínuo.md) ($x_c(t)$):\n\n$$ x(n) = x_c(nT_s), \\forall n \\in \\mathbb{Z} $$\nem que $x_c(t)$ é uma função da variável $t \\in \\mathbb{R}$ e $T$ é o [período de amostragem](aulas/aula01/ss-sin-conc/período%20de%20amostragem.md).\n\n![amost](aulas/aula01/ss-sin-conc/attachments/amost.svg)\n\nPróximo: [período de amostragem](aulas/aula01/ss-sin-conc/período%20de%20amostragem.md)","lastmodified":"2022-11-17T15:36:24.729381102Z","tags":null},"/aulas/aula01/ss-sin-conc/codifica%C3%A7%C3%A3o-da-amplitude":{"title":"codificação da amplitude","content":"\nPara além da amostragem temporal, a amplitude do sinal pode também ser codificada usando um número finito de bits.\n\nNo caso de uma codificação linear de 16 bits em complemento para 2:\n\n$$s: \\mathbb{Z} \\rightarrow \\\\\\{-32768, \\ldots, 32767 \\\\\\}$$\n\nNo caso de uma imagem quadrada com 512x512 pixeis de com 8 bits por cada componente RGB (24 bits):\n\n$$ i: \\\\\\{0, \\ldots, 511\\\\\\}^2 \\rightarrow \\\\\\{0, \\ldots, 255 \\\\\\}^3 $$\n\nPróximo: [energia de um sinal](aulas/aula01/ss-sin-conc/energia%20de%20um%20sinal.md)\n\n","lastmodified":"2022-11-17T15:36:24.741381261Z","tags":null},"/aulas/aula01/ss-sin-conc/conjunto-de-n%C3%BAmeros":{"title":"conjunto de números","content":"\nSendo um conjunto uma coleção de objetos, um conjunto de números é uma coleção de números:\n\n$$n \\in \\\\\\{ 1, 3, 5, 7 \\\\\\}$$\n\nConvencionou-se utilizar certas letras para representar conjuntos infinitos de números. As seguintes expressões são verdadeiras:\n\n* números naturais: $0 \\notin \\mathbb{N}$\n* números naturais incluindo o zero: $0 \\in \\mathbb{N_0}$\n* números inteiros: $-1 \\in \\mathbb{Z}$\n* números racionais: $\\frac{1}{3} \\in \\mathbb{Q}$\n* números reais: $\\pi \\in \\mathbb{R}$\n* números complexos: $(1+j) \\in \\mathbb{C}$\n\nOs números reais ($\\mathbb{R}$) podem-se representar com intervalos:\n\n$$(-1 \\in [-1,1]) \\land (-1 \\notin ]-1,1])\n$$\n\nPróximo: [sinal em tempo contínuo](aulas/aula01/ss-sin-conc/sinal%20em%20tempo%20contínuo.md)","lastmodified":"2022-11-17T15:36:24.741381261Z","tags":null},"/aulas/aula01/ss-sin-conc/energia-de-um-sinal":{"title":"energia de um sinal","content":"\n\nConvencionou-se definir a energia de um [sinal em tempo contínuo](aulas/aula01/ss-sin-conc/sinal%20em%20tempo%20contínuo.md) como sendo:\n\n$$E_\\infty = \\int_{-\\infty}^{+\\infty} |x(t)|^2 dt$$\n\nDe forma análoga para um [sinal em tempo discreto](aulas/aula01/ss-sin-conc/sinal%20em%20tempo%20discreto.md):\n\n$$ E_\\infty = \\sum_{n=-\\infty}^{+\\infty} |x(n)|^2 $$\n\nNota importante: podem existir sinais de energia infinita.\n\nPróximo: [potência de um sinal](aulas/aula01/ss-sin-conc/potência%20de%20um%20sinal.md)\n\n","lastmodified":"2022-11-17T15:36:24.741381261Z","tags":null},"/aulas/aula01/ss-sin-conc/fun%C3%A7%C3%A3o-matem%C3%A1tica":{"title":"função matemática","content":"\n\nEm matemática, uma função $f$ atribuí a cada elemento do conjunto $D$, o domínio, exatamente um elemento do conjunto $C$, o conjunto de chegada.\n\nEsta atribuição pode ser representada da seguinte forma:\n$$ f: D \\rightarrow C$$\nPor exemplo, a função complexa de variável real $f(x), x \\in \\mathbb{R}$ é representada como:\n$$ f: \\mathbb{R} \\rightarrow \\mathbb{C}$$\nO domínio e o contradomínio podem ser qualquer [conjunto de números](aulas/aula01/ss-sin-conc/conjunto%20de%20números.md)\n\nPróximo: [conjunto de números](aulas/aula01/ss-sin-conc/conjunto%20de%20números.md)","lastmodified":"2022-11-17T15:36:24.741381261Z","tags":null},"/aulas/aula01/ss-sin-conc/imagem-digital":{"title":"imagem digital","content":"\n\nUma imagem digital é uma função com o seguinte domínio e contra-domínio:\n\n$$ ImagemDigital: VertDiscreto \\times HorizDiscreto \\rightarrow Inteiros $$\nPor exemplo:\n\n![baboong](aulas/aula01/ss-sin-conc/attachments/baboong.gif)\n\nPróximo: [video digital](aulas/aula01/ss-sin-conc/video%20digital.md)\n","lastmodified":"2022-11-17T15:36:24.741381261Z","tags":null},"/aulas/aula01/ss-sin-conc/per%C3%ADodo-de-amostragem":{"title":"período de amostragem","content":"\n\nO período de amostragem ($T$) é o intervalo de tempo entre duas amostras de um sinal contínuo.\n\nÉ mais comum indicar-se o [ritmo ou frequência de amostragem](aulas/aula01/ss-sin-conc/ritmo%20ou%20frequência%20de%20amostragem.md) ($F_s$) para caracterizar um [sinal em tempo discreto](aulas/aula01/ss-sin-conc/sinal%20em%20tempo%20discreto.md) resultante da amostragem de um [sinal em tempo contínuo](aulas/aula01/ss-sin-conc/sinal%20em%20tempo%20contínuo.md).\n\nO período de amostragem tem a seguinte relação com a frequência de amostragem:\n$$\nT=\\frac{1}{F_s}\n$$\n\nPróximo: [ritmo ou frequência de amostragem](aulas/aula01/ss-sin-conc/ritmo%20ou%20frequência%20de%20amostragem.md)\n","lastmodified":"2022-11-17T15:36:24.741381261Z","tags":null},"/aulas/aula01/ss-sin-conc/pot%C3%AAncia-de-um-sinal":{"title":"potência de um sinal","content":"\nCom base na definição da [energia de um sinal](aulas/aula01/ss-sin-conc/energia%20de%20um%20sinal.md), podemos  definir a potência média de um [sinal em tempo contínuo](aulas/aula01/ss-sin-conc/sinal%20em%20tempo%20contínuo.md)\n$$ P_\\infty = \\lim_{T \\rightarrow \\infty} \\frac{1}{2T} \\int_{-T}^{+T} |x(t)|^2 dt$$\n\nDe forma análoga para um [sinal em tempo discreto](aulas/aula01/ss-sin-conc/sinal%20em%20tempo%20discreto.md):\n$$ P_\\infty = \\lim_{N \\rightarrow \\infty} \\frac{1}{2N + 1} \\sum_{n=-N}^{+N} |x(n)|^2$$\n\n\nPróximo: [1-2 Transformação da variável independente](topicos/1-2%20Transformação%20da%20variável%20independente.md)\n\n\n","lastmodified":"2022-11-17T15:36:24.741381261Z","tags":null},"/aulas/aula01/ss-sin-conc/ritmo-ou-frequ%C3%AAncia-de-amostragem":{"title":"ritmo ou frequência de amostragem","content":"\n\nO ritmo ou frequência de amostragem ($F_s$) é o número de vezes por segundo que se amostra um [sinal em tempo contínuo](aulas/aula01/ss-sin-conc/sinal%20em%20tempo%20contínuo.md) para se obter um [sinal em tempo discreto](aulas/aula01/ss-sin-conc/sinal%20em%20tempo%20discreto.md).\n\nO ritmo ou frequência de amostragem representa-se em amostras/segundo ou $Hz$.\n\nPara amostrar um [sinal acústico](aulas/aula01/ss-sin-conc/sinal%20acústico.md) usa-se frequentemente o ritmo de amostragem de $44100 Hz$ para que o [sinal em tempo discreto](aulas/aula01/ss-sin-conc/sinal%20em%20tempo%20discreto.md) resultante contenha todas as frequências audíveis pelos humanos.\n\n\nPróximo: [tom puro em tempo discreto](aulas/aula01/ss-sin-conc/tom%20puro%20em%20tempo%20discreto.md)\n","lastmodified":"2022-11-17T15:36:24.741381261Z","tags":null},"/aulas/aula01/ss-sin-conc/sinal-ac%C3%BAstico":{"title":"sinal acústico","content":"\nSe $s$ for um sinal acústico:\n\n$$ s: \\text{Tempo} \\rightarrow \\text{Pressão}$$\n\nPodemos representá-lo como uma [função matemática](aulas/aula01/ss-sin-conc/função%20matemática.md):\n\n$$ \\forall t \\in \\mathbb{R}, s(t) = \\ldots $$\n$$ s: \\mathbb{R} \\rightarrow \\mathbb{R} $$\nTrata-se de um [sinal em tempo contínuo](aulas/aula01/ss-sin-conc/sinal%20em%20tempo%20contínuo.md) que pode ser representado graficamente:\n\n![som](aulas/aula01/ss-sin-conc/attachments/som.svg)\n\n\nUm [tom puro em tempo contínuo](aulas/aula01/ss-sin-conc/tom%20puro%20em%20tempo%20contínuo.md) é um exemplo de um sinal acústico.\n\nPróximo: [função matemática](aulas/aula01/ss-sin-conc/função%20matemática.md)","lastmodified":"2022-11-17T15:36:24.741381261Z","tags":null},"/aulas/aula01/ss-sin-conc/sinal-bi-dimensional":{"title":"sinal bi-dimensional","content":"\nUma fotografia a preto e branco pode também ser representada por uma função:\n\n$$ ImagemPB: EspacoVert \\times EspacoHoriz \\rightarrow Intensidade $$\n\nou seja,\n\n$$ i = ImagemPB(x,y) $$\n\nPara uma imagem a cores:\n\n$$ ImagemCores: EspacoVert \\times EspacoHoriz \\rightarrow Intensidade^3 $$\n\nPróximo: [sinal em tempo discreto](aulas/aula01/ss-sin-conc/sinal%20em%20tempo%20discreto.md)","lastmodified":"2022-11-17T15:36:24.741381261Z","tags":null},"/aulas/aula01/ss-sin-conc/sinal-em-tempo-cont%C3%ADnuo":{"title":"sinal em tempo contínuo","content":"\nUm sinal $x(t)$ em tempo contínuo é uma função de uma variável real ($\\mathbb{R}$).\n$$\n\\forall t \\in \\mathbb{R}, x(t) = \\ldots\n$$\nna forma de uma [função matemática](aulas/aula01/ss-sin-conc/função%20matemática.md) que faz o mapeamento de um domínio num conjunto de chegada:\n$$\n x: \\mathbb{R} \\rightarrow \\mathbb{R}\n$$\nÉ frequente denominar estes sinais pela forma abreviada de _sinais contínuos_.\n\nUm [sinal acústico](aulas/aula01/ss-sin-conc/sinal%20acústico.md) é um exemplo de um sinal em tempo contínuo uni-dimensional porque o domínio só tem uma dimensão. Uma imagem é um [sinal bi-dimensional](aulas/aula01/ss-sin-conc/sinal%20bi-dimensional.md).\n\nUm sinal que é função de uma variável inteira ($\\mathbb{Z}$) é um [sinal em tempo discreto](aulas/aula01/ss-sin-conc/sinal%20em%20tempo%20discreto.md).\n\nPróximo: [tom puro em tempo contínuo](aulas/aula01/ss-sin-conc/tom%20puro%20em%20tempo%20contínuo.md)\n","lastmodified":"2022-11-17T15:36:24.741381261Z","tags":null},"/aulas/aula01/ss-sin-conc/sinal-em-tempo-discreto":{"title":"sinal em tempo discreto","content":"\n\nUm sinal $x(n)$ em tempo discreto é uma função de uma variável discreta.\n\n$$\n\\forall t \\in \\mathbb{R}, x(t) = \\ldots\n$$\nna forma de uma [função matemática](aulas/aula01/ss-sin-conc/função%20matemática.md)\n$$\n x: \\mathbb{Z} \\rightarrow \\mathbb{R}\n$$\n\nEm que $\\mathbb{Z}$ é o [conjunto de números](aulas/aula01/ss-sin-conc/conjunto%20de%20números.md) inteiros.\n\nÉ frequente denominar estes sinais pela forma abreviada de _sinais discretos_.\n\nO [valor de fecho de índice de bolsa](aulas/aula01/ss-sin-conc/valor%20de%20fecho%20de%20índice%20de%20bolsa.md) é um exemplo de um sinal em tempo discreto, bem como uma [imagem digital](aulas/aula01/ss-sin-conc/imagem%20digital.md) e um [video digital](aulas/aula01/ss-sin-conc/video%20digital.md).\n\nPróximo: [valor de fecho de índice de bolsa](aulas/aula01/ss-sin-conc/valor%20de%20fecho%20de%20índice%20de%20bolsa.md)","lastmodified":"2022-11-17T15:36:24.741381261Z","tags":null},"/aulas/aula01/ss-sin-conc/tom-puro-em-tempo-cont%C3%ADnuo":{"title":"tom puro em tempo contínuo","content":"\n\nUm tom puro é um sinal sinusoidal:\n$$\\forall t \\in \\mathbb{R}, x(t) = \\sin(2 \\pi \\times 440 t)$$\n$$x: \\mathbb{R} \\rightarrow [-1,1] $$\n\nOs instrumentais musicais são frequentemente afinados com a frequência de 440 Hz que corresponde à nota Lá 440 (A4) na oitava central de um piano.\n\n\nPróximo: [sinal bi-dimensional](aulas/aula01/ss-sin-conc/sinal%20bi-dimensional.md)","lastmodified":"2022-11-17T15:36:24.741381261Z","tags":null},"/aulas/aula01/ss-sin-conc/tom-puro-em-tempo-discreto":{"title":"tom puro em tempo discreto","content":"\n\nA equação do sinal de tom puro resultante da amostragem do sinal em tempo contínuo:\n$$\\forall n \\in \\mathbb{Z},\\; x(n) = \\sin(\\frac{2\\pi}{F_s} \\times 440 n)$$\n$$x: \\mathbb{Z} \\rightarrow [-1,1] $$\n\nPróximo: [codificação da amplitude](aulas/aula01/ss-sin-conc/codificação%20da%20amplitude.md)\n","lastmodified":"2022-11-17T15:36:24.741381261Z","tags":null},"/aulas/aula01/ss-sin-conc/valor-de-fecho-de-%C3%ADndice-de-bolsa":{"title":"valor de fecho de índice de bolsa","content":"\n\nO índice de um mercado de capitais é uma combinação da cotação das ações das empresas mais importantes desse mercado, pesada pela suas capitalizações em bolsa.\n\nNa análise da evolução histórica de um índice usa-se normalmente o seu valor no final do dia (fecho do mercado).\n\n![index-djones-nasdaq-sp500](aulas/aula01/ss-sin-conc/attachments/index-djones-nasdaq-sp500.png)\n\nPróximo: [imagem digital](aulas/aula01/ss-sin-conc/imagem%20digital.md)","lastmodified":"2022-11-17T15:36:24.741381261Z","tags":null},"/aulas/aula01/ss-sin-conc/video-digital":{"title":"video digital","content":"\n\nUm sinal de video digital é uma sequência de imagens (frames)\nassociadas a instantes de tempo:\n$$ VideoDigital: Tempo \\times VertDiscr \\times HorizDiscr \\rightarrow Intensidade^3 $$\n\n\nPróximo: [amostragem de um sinal em tempo contínuo](aulas/aula01/ss-sin-conc/amostragem%20de%20um%20sinal%20em%20tempo%20contínuo.md)\n","lastmodified":"2022-11-17T15:36:24.741381261Z","tags":null},"/aulas/aula01/ss-tvi-conc/complexo-conjugado":{"title":"complexo conjugado","content":"\n\nO conjugado de um número complexo ($z=a+jb$) é o número complexo que tem a mesma parte real, e a parte imaginária tem o sinal oposto ($z^\\ast=a-jb$).\n$$\\Re\\{z^\\ast\\} = \\Re\\{z\\}$$\n$$\\Im\\{z^\\ast\\} = - \\Im\\{z\\}$$\nNa forma polar ($z=|z|e^{j\\varphi}$) o módulo mantém-se e o ângulo muda de sinal ($z^\\ast = |z|e^{-j\\varphi}$), como se poderá facilmente demonstrar com a [fórmula de Euler](aulas/aula01/ss-tvi-conc/fórmula%20de%20Euler.md)\n\nPróximo: [fórmula de Euler](aulas/aula01/ss-tvi-conc/fórmula%20de%20Euler.md)\n","lastmodified":"2022-11-17T15:36:24.741381261Z","tags":null},"/aulas/aula01/ss-tvi-conc/componente-par-e-%C3%ADmpar-de-um-sinal":{"title":"componente par e ímpar de um sinal","content":"\n\nQualquer sinal pode ser decomposto na soma de um sinal par com um\nsinal ímpar:\n$$ x(t) = x_e(t) + x_o(t)$$\n\nEm que $x_e(t)$ é a componente par e $x_o(t)$ a componente ímpar.\n\nAs componentes pares e ímpares podem-se obter a partir de:\n$$\\begin{eqnarray*}\nx_e(t) \u0026=\u0026 \\frac{1}{2} [ x(t) + x^\\ast(-t) ] \\\\\nx_o(t) \u0026=\u0026 \\frac{1}{2} [ x(t) - x^\\ast(-t) ]\n\\end{eqnarray*}$$\n\nPróximo: \n","lastmodified":"2022-11-17T15:36:24.741381261Z","tags":null},"/aulas/aula01/ss-tvi-conc/deslocamento-temporal-em-tempo-cont%C3%ADnuo":{"title":"deslocamento temporal em tempo contínuo","content":"\n\nDeslocamento temporal pela constante $t_0$:\n\n$y(t)=x(t-t_0),\\; t, t_0 \\in \\mathbb{R}$\n\nExemplo para $t_0\u003e0$:\n\n![deslc](aulas/aula01/ss-tvi-conc/attachments/deslc.svg)\n\nPróximo: [inversão temporal](aulas/aula01/ss-tvi-conc/inversão%20temporal.md)\n","lastmodified":"2022-11-17T15:36:24.741381261Z","tags":null},"/aulas/aula01/ss-tvi-conc/escalamento-temporal":{"title":"escalamento temporal","content":"\n\nA multiplicação da variável independente por uma constante $a$ faz uma expansão ou contração do gráfico da função:\n\n$y(t)=x(at),\\; t,a \\in \\mathbb{R}$\n\nExemplo para $a \\in ]0,1[$:\n\n![escalc](aulas/aula01/ss-tvi-conc/attachments/escalc.svg)\n\nNota: a [inversão temporal](aulas/aula01/ss-tvi-conc/inversão%20temporal.md) é um caso particular do escalamento temporal.\n\nSeguinte: [sinais pares e ímpares](aulas/aula01/ss-tvi-conc/sinais%20pares%20e%20ímpares.md)\n\n","lastmodified":"2022-11-17T15:36:24.741381261Z","tags":null},"/aulas/aula01/ss-tvi-conc/f%C3%B3rmula-de-Euler":{"title":"fórmula de Euler","content":"\n\nA fórmula de Euler é usada em análise complexa e estabelece a relação entre a função exponencial complexa e as funções trigonométricas do seno e do cosseno:\n$$e^{j\\varphi} = \\cos(\\varphi) + j \\sin(\\varphi) ,\\; \\forall \\varphi \\in \\mathbb{R}$$\n\n![formula-euler](aulas/aula01/ss-tvi-conc/attachments/formula-euler.png)\n\nPróximo: [sinais pares e ímpares](aulas/aula01/ss-tvi-conc/sinais%20pares%20e%20ímpares.md)","lastmodified":"2022-11-17T15:36:24.741381261Z","tags":null},"/aulas/aula01/ss-tvi-conc/invers%C3%A3o-temporal":{"title":"inversão temporal","content":"\nA multiplicação por $-1$ da variável independente faz a inversão temporal da função:\n\n$y(t)=x(-t),\\; t \\in \\mathbb{R}$\n\n![invc](aulas/aula01/ss-tvi-conc/attachments/invc.svg)\n\nSeguinte: [escalamento temporal](aulas/aula01/ss-tvi-conc/escalamento%20temporal.md)\n","lastmodified":"2022-11-17T15:36:24.741381261Z","tags":null},"/aulas/aula01/ss-tvi-conc/sinais-pares-e-%C3%ADmpares":{"title":"sinais pares e ímpares","content":"\n\nUm sinal é _par_ se for igual à sua inversão temporal\n$$x(t)=x^\\ast(-t),\\; \\forall t \\in \\mathbb{R}$$\nOnde $x^\\ast$ representa o [complexo conjugado](aulas/aula01/ss-tvi-conc/complexo%20conjugado.md) de $x$\n\nUm sinal é _ímpar_ se:\n$$x(t)=-x^\\ast(-t),\\; \\forall t \\in \\mathbb{R}$$\n\nPor exemplo, sinal real $x(t)$ é par enquanto o sinal real $y(t)$ é ímpar:\n\n![parimpar](aulas/aula01/ss-tvi-conc/attachments/parimpar.svg)\n\nSeguinte: [componente par e ímpar de um sinal](aulas/aula01/ss-tvi-conc/componente%20par%20e%20ímpar%20de%20um%20sinal.md)\n","lastmodified":"2022-11-17T15:36:24.741381261Z","tags":null},"/jupyter/complex-exp/complex-exp":{"title":"","content":"\n# A exponencial complexa\n\n_Luis Caldas de Oliveira_\n\nEste notebook apresenta a exponencial complexa e a sua utilização na representação de sinais. A função exponencial complexa tem um papel central na análise e processamento de sinais.\n\n\n## Função exponencial\n\nA fómula de Euler:\n$$e^{j\\varphi} = \\cos(\\varphi) + j \\sin(\\varphi) ,\\; \\forall \\varphi \\in \\mathbb{R}$$\n\nPermite-nos representar um número complexo na forma polar (módulo e argumento) de uma forma compacta:\n$$\nz = |z| \\cos(\\angle z) + j |z| \\sin(\\angle z) = |z| e^{j\\angle z}\n$$\n\n\n```python\nimport numpy as np\nimport sympy as sp\nfrom IPython.display import display, Math\nsp.init_printing()\n\nimport matplotlib.pyplot as plt\nplt.rcParams['figure.figsize'] = [8, 8]\n\nt, sigma, omega, phi = sp.symbols('t sigma omega, phi', real=True)\n\nphi = sp.pi/3\ndisplay(Math('\\phi = ' + sp.latex(phi)))\n\nz1 = sp.exp(sp.I * phi)\ndisplay(Math('z_1 = ' + sp.latex(z1) + \n             ' = ' + sp.latex(sp.re(z1)) + '+ i' + sp.latex(sp.im(z1)) ))\n        \nz = complex(z1)\n\n\n\nax = plt.subplot(111)\nuc = plt.Circle((0,0), radius=1, fill=False,\n                        color='black', ls='dashed')\nax.add_patch(uc)\nt1 = plt.plot(z.real, z.imag, 'go', ms=10)\n\nplt.setp(t1, markersize=5.0, markeredgewidth=1.0,\n              markeredgecolor='r', markerfacecolor='r')\nax.spines['left'].set_position('center')\nax.spines['bottom'].set_position('center')\nax.spines['right'].set_visible(False)\nax.spines['top'].set_visible(False)\n\nr = 1.5; plt.axis('scaled')\nplt.axis([-r, r, -r, r])\nticks = [-1, -.5, .5, 1]\nplt.xticks(ticks)\nplt.yticks(ticks)\n\nax.annotate(' z1', (z.real,z.imag),fontsize=14)\nax.quiver(0, 0, z.real, z.imag, angles='xy', scale_units='xy',color=['r','b'],scale=1)\nplt.grid()\nplt.show()\n```\n\n\u003c!-- #region --\u003e\n## Sinal exponencial complexo em tempo contínuo\n\n\nUm sinal exponencial complexo em tempo contínuo $x(t)$ é definido pela função exponencial complexa:\n$$ x(t) = e^{st}, \\; t \\in \\mathbb{R}, \\; s \\in \\mathbb{C}$$\nEm que $s$ é a frequência complexa. \ne representando o número complexo na forma $s=\\sigma+j\\omega$ com $\\sigma,\\omega \\in \\mathbb{R}$, podemos exprimir o sinal como:\n$$\nx(t) = e^{(\\sigma + j \\omega) t} = e^{\\sigma t} \\cos(\\omega t) + j e^{\\sigma t} \\sin(\\omega t)\n$$\n\nNa implementação em SymPy é importante notar que `sympy.I` corresponde a $j$ e que a impressão de expressões usa a letra $i$ em vez de $j$. \n\u003c!-- #endregion --\u003e\n\n```python\n\ns = sigma + sp.I*omega\nx = sp.exp(s*t)\ndisplay(x)\n```\n\nPodemos agora atribuir valores à frequência complexa e representar a parte real e imaginária do sinal $x(t)$.\n\nNotar que\n$$\\omega = 2 \\pi /T$$\nem que $T$ é o período da oscilação amortecida em segundos.\n\nA envolvente do amortecimento tem a expressão:\n$$e^{\\sigma t} = e^{-t/\\tau}$$\nO valor de $\\tau$ dá uma ideia da velocidade de decaimento da exponencial pois quando $t=\\tau$ a amplitude da exponencial reduziu-se em $e^{-1} \\approx 37%$ do seu valor inicial.\n\n```python\nT = 2\ntau = 4\ny = x.subs({omega: 2*sp.pi/T, sigma: -1/tau})\n\nsp.plot(sp.re(y), (t, 0, 2*sp.pi), ylabel='$\\Re(e^{st})$', line_color='red')\nsp.plot(sp.im(y), (t, 0, 2*sp.pi), ylabel='$\\Im(e^{st})$', line_color='red');\n```\n\n## Sinal exponencial complexo em tempo discreto\n\nO sinal exponencial complexo em tempo discreto é definido pela função exponencial complexa:\n$$\nx(n) = e^{(\\Sigma + j \\Omega) \\, n} = z^n\n, \\; n \\in \\mathbb{Z}\n, \\; \\Sigma,\\Omega  \\in \\mathbb{R}\n, \\; z \\in \\mathbb{C}\n\nem que $z = e^{\\Sigma + j \\Omega}$ se denomina com frequência complexa.\n\nComeçamos por importar a biblioteca NumPy e definir uma função para traçar o gráfico de um sinal em tempo discreto\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\ndef PlotDSignal(var: np.array, signal: np.array, name: str) -\u003e None:\n    markerline, stemlines, baseline = plt.stem(\n        var, signal,\n        linefmt='red',markerfmt='o',basefmt='black')\n    markerline.set_color('red')\n    markerline.set_markerfacecolor('none')\n    plt.stem(var, signal,linefmt='red',markerfmt='o',basefmt='black')\n    plt.xlabel('$n$')\n    plt.ylabel('$'+name+'$')\n    print(name)\n    plt.show()\n    return\n\n\n```\n\nPodemos agora definir o sinal em tempo discreto:\n$$x(n) = e^{(\\Sigma + j \\Omega) \\, n}$$\n\n```python\ndef xd(n, Sigma, Omega):\n    return np.exp((Sigma + 1j * Omega) * n)\n```\n\nE traçar os gráficos da sua parte real e imaginária\n\n```python\nn = np.arange(31)\nOmega = 2*np.pi/10\nSigma = -1/10\nPlotDSignal(n, np.real(xd(n, Sigma, Omega)), 'Re(x(n))')\nPlotDSignal(n, np.imag(xd(n, Sigma, Omega)), 'Im(x(n))')\n\n```\n\n## Amostragem de sinal periódico em tempo contínuo\n\nA amostragem de um sinal periódico em tempo contínuo nem sempre resulta num sinal periódico em tempo discreto.\n\nConsiderando o sinal periódico:\n$$x_c(t) = x_c(t+T) , \\;\\; T \\in \\mathbb{R} \\land \\forall t \\in \\mathbb{R}$$\n\n```python\nT = 2\nomega = 2*np.pi/T\nxc = t % T\n\nsp.plot(xc, (t, 0, 6),\n        ylabel='$\\sin(\\omega t)$', line_color='red');\n```\n\nO sinal amostrado $x_d(n) = x_c(nT_s)$.\n\nSe $NT_s=kT$ com $k \\in \\mathbb{Z}$ então \n\n```python\nTs = T/10\nn = sp.Symbol('n', integer=True)\nxd1 = xc.subs(t, n*Ts)\nxd1n = sp.lambdify(n , xd1, \"numpy\")\nk = np.arange(0, 31)\n\nPlotDSignal(k, xd1n(k), 'xd1(n)')\n\n\nfor k in range(1,20):\n    N = k*T/Ts               \n    if N.is_integer():\n        break\n        \nif N.is_integer():\n    print(\"Periódico com N =\",N)\nelse:\n    print(\"Não periódico\")\n\n\n```\n\nSe $T$ não for múltiplo de $T_s$. \n\n```python\nTs = 1/3\nn = sp.Symbol('n', integer=True)\nxd2 = xc.subs(t, n*Ts)\nxd2n = sp.lambdify(n , xd2, \"numpy\")\nk = np.arange(0, 8)\n\nPlotDSignal(k, xd2n(k), 'xd2(n)')\n\nfor k in range(1,20):\n    N = k*T/Ts               \n    if N.is_integer():\n        break\n        \nif N.is_integer():\n    print(\"Periódico com N=\",N)\nelse:\n    print(\"Não periódico\")\n    \nprint(xd2.subs(n,6))\n```\n\n```python\n\n```\n","lastmodified":"2022-11-17T15:36:24.745381314Z","tags":null},"/jupyter/intro-jupyter-python/intro-jupyter-python":{"title":"","content":"\n# Introdução aos Jupyter notebooks e ao Python\n\n_Luis Caldas de Oliveira_\n\nEste notebook tem como objetivo explicar o que é um Jupyter notebook e fazer uma breve introdução à linguagem de programação Python.\n\n\n## Jupyter Notebooks\n\nUm Jupyter Notebook é um ficheiro com extensão `.ipynb` que é composto por uma sequência de blocos denominados de células. Existem células de texto e células de código que podem ser editadas clicando nelas com o rato (as células de texto precisam de um duplo clique).\n\n### Células de código\n\nA célula seguinte é um exemplo de uma célula de código:\n\n```python\nprint (\"Célula de código\")\n```\n\nUma célula de código pode ser executada, sendo o resultado do da execução do código apresentado logo a seguir à célula. Para executar uma célula de código basta selecionar a célula e carregar em `Run` na barra de ferramentas no topo do notebook. Nessa barra existe também um botão com `+` que cria uma nova célula a seguir à célula atualmente ativa. A nova célula é, por omissão, uma célula de código que se identifica por ter à sua esquerda a sequência `In [ ]`. Depois de executada a célula de código é colocado um número no espaço entre os parênteses retos que indica a ordem em que as células foram executadas. A memória é persistente o que significa que, por exemplo, o valor das variáveis é mantido até à execução de outra célula e é independente da sua posição no notebook.\n\n\n\n### Células de Texto\n\nPara mudar uma célula de código para uma célula de texto muda-se o seletor da barra de ferramentas de `Code` para `Markdown` indicando que o texto deve ser formatado de acordo com esta norma.\n\nEste é um exemplo de texto em Markdown:\n\n````\n# Título de nível 1\n## Título de nível 2\n### Título de nível 3\n\nLista de items:\n- **primeiro em negrito**\n- *segundo em itálico*\n- _terceiro em itálico_\n\nLista enumerada\n1. primeiro\n2. segundo\n3. terceiro\n\nvariável `a` e segmento de código\n```\nprint (\"segmento de código\")\n```\n````\n\nApós a execução da célula de texto com o comando `Run` o texto fica formatado assim:\n\n# Título de nível 1\n## Título de nível 2\n### Título de nível 3\n\nLista de items:\n- **primeiro em negrito**\n- *segundo em itálico*\n- _terceiro em itálico_\n\nLista enumerada\n1. primeiro\n2. segundo\n3. terceiro\n\nvariável `a` e segmento de código\n```\nprint (\"segmento de código\")\n```\n\nO interpretador de Markdown também aceita fórmula matemáticas em LaTeX. Por exemplo, a sequência:\n```\nExpressão no meio do texto $\\sqrt{2}$ ou equação matemática:\n$$ x = \\frac{-b \\pm \\sqrt{b^2 - 4 a c}}{2a} $$\n```\nResulta em:\n\nExpressão no meio do texto $\\sqrt{2}$ ou equação matemática:\n$$ x = \\frac{-b \\pm \\sqrt{b^2 - 4 a c}}{2a} $$\n\n\n\n### Truques e atalhos do Jupyter\n\nÉ possível executar comandos do interpretador de comandos do computador (shell) numa célula de código usando o símbolo `!` antes do comando.\nPor exemplo para saber a diretoria atual:\n\n```python\n!pwd\n```\n\nPode-se também usar comandos especiais do iPython como o `%timeit`para medir o tempo de execução do código:\n\n```python\n%timeit [x**2 for x in range(100)]\n```\n\nPode-se também usar `?` para obter ajuda sobre um comando:\n\n```python\n?print\n```\n\nTambém se pode usar o **Tab** para completar o texto ou **Shift-Tab** para obter uma ajuda rápida.\n\n\n## Python Básico\n\n### Variáveis e operações básicas\n\nO Python segue as normas habituais para os operadores de atribuição (`=`), soma (`+`), subtração (`-`), multiplicação (`*`) e divisão (`/`). Em Python as variáveis não precisam de ser declaradas, assumindo o tipo adequado à atribuição que for feita.\n\n```python\ninteiro = 3\nreal = 3.2\ncadeia = \"abcd\"\nprint (inteiro, \" \", real, \" \", cadeia)\n```\n\nUma atribuição pode mudar o tipo da variável\n\n```python\nreal = cadeia\nprint(real)\n```\n\nUma das coisas mais originais do Python é que a identação do código é a forma de expecificar um bloco.\nPor exemplo na instrução `if`, o código a executar no caso da condição ser verdadeira deve estar identado:\n\n```python\nx, y = 5, 2\nif x \u003e 2:\n    print (x, \"\u003e\", y)\nelse:\n    print (x, \"\u003c\", y)\n```\n\n### Tipos de dados\n\nO Pyhthon tem 6 tipos de dados básicos: inteiros, números de vírgula flutuante, cadeias de carateres, listas, tuplos e dicionários.\nOs 3 primeiros são semelhantes a outras linguagens de programação mas os restantes necessitam de uma explicação adicional\n\n\n#### Listas\n\nAs listas são semelhantes aos vetores de outras linguagem mas em que cada elemento pode ter um tipo diferente.\nO Python permite por exemplo:\n\n```python\nlista = [1, 2.1, \"abcd\"]\nprint(lista[0])\n```\n\nO primeiro elemento de uma lista tem o índice `0`. Pode-se obter o comprimento de uma lista com a função `len()`. Para imprimir o último elemento da lista pode-se fazer:\n\n```python\nprint(lista[len(lista)-1])\n```\n\nou mais facilmente:\n\n```python\nprint(lista [-1])\n```\n\n#### Tuplos\n\nUm tuplo é usado para guardar vários objetos numa única variável. A diferença entre uma lista e um tuplo é o os elementos da primeira podem ser alterados enquanto um tuplo é imutável, ou seja, tem de se mudar todos os seus elementos.\n\n```python\nlista = [0.5, 0.7, 0.9]\ntuplo = (0.5, 0.7, 0.9)\nprint(lista, tuplo)\nlista[0] = 0.1\ntry:\n    tuplo[0] = 0.1\nexcept TypeError:\n    print(\"Erro: um tuplo é imutável\")\nprint(lista, tuplo)\n```\n\n#### Dicionários\n\nUm dicionário é uma lista em que cada elemento é indexado por uma chave.\n\n```python\nnomes_alunos = {\"João\": 5, \"Maria\": 3}\nnomes_alunos[\"Pedro\"] = 2\nprint(nomes_alunos[\"Pedro\"])\nprint(nomes_alunos.keys())\nprint(nomes_alunos.items())\n```\n\n### Objetos em Python\n\nEm Python tudo é um objeto, ou seja, uma instância de uma classe que tem associada um conjunto de comportamentos oferecido pela classe.\n\nEstes comportamentos assumem a forma de propriedades (atributos do objeto) e métodos (funções que atuam sobre o objeto).\n\nPor exemplo, podemos criar uma variável `z` que é uma instância da classe dos números complexos e que tem associado as propriedades `real` e `imag` e o método `conjugate()`:\n\n```python\nz = 1 + 2j\nprint(z)\nprint(type(z))\nprint(\"Re(z)=\", z.real, \" Im(z)=\",z.imag)\nprint(z.conjugate())\n```\n\n### Cadeias de carateres e listas\n\nAs listas e as cadeias de carateres são dois objetos relacionados e que têm alguns métodos comuns:\n\n\n```python\nlista = [1, 2, 3, 4, 5]\ncadeia = \"Era uma vez um gato\"\nprint(lista[2:5], cadeia[2:5])\nprint(lista.count(3), cadeia.count(\"a\"))\nprint(len(lista), len(cadeia))\nprint(lista + [6], cadeia + \".\")\n```\n\nHá no entanto métodos específicos para [cadeias de carateres](https://www.w3schools.com/python/python_ref_string.asp) e para [listas](https://www.w3schools.com/python/python_ref_list.asp).\nAlguns exemplos:\n\n```python\npalavras = cadeia.split()\nprint(palavras)\npalavras.append(\"maltês\")\nprint(palavras)\npalavras.sort()\nprint(palavras)\n```\n\n### Ciclos em Python\n\nOs ciclos são construídos com a instrução `for a in b` em que `a` é uma variável e `b` é uma lista. Por exemplo:\n\n```python\nsinal = [10, 11, 12]\nfor n in [0, 1, 2]:\n    print(sinal[n])\n```\n\nÉ mais elegante iterar sobre a própria lista\n\n```python\nsinal = [10, 11, 12]\nfor amostra in sinal:\n    print(amostra)\n```\n\nA função `range()` gera um objeto para iterar\n\n```python\nsinal = [10, 11, 12]\nfor n in range(3):\n    print(sinal[n])\n```\n\nOs ciclos podem também ser usados para gerar uma lista\n\n```python\nlista_inteiros = [5, 6, 7, 8]\nlista_carateres = [str(i) for i in lista_inteiros]\nprint(lista_carateres)\n```\n\n### Funções\n\nAs funções são definidas com a instrução `def nome(argumentos):` seguida de um bloco identado com o código da função terminado com\na instrução `return ...`.\n\nPor exemplo:\n\n```python\ndef soma_5(lista_entrada):\n    lista_saida = [i+5 for i in lista_entrada]\n    return lista_saida\n\nprint(soma_5([10, 11, 12]))\n```\n\nSe a função tiver mais de um argumento, estes separam-se com vírgulas.\nPodem também ser atribuídos valores por omissão aos argumentos se estes não forem definidos quando a função é chamada.\n\nÉ boa prática indicar na definição da função a classe de objetos que aceita à entrada e a que resulta da sua execução.\n\n```python\ndef soma_val(lista_entrada: list, val: int = 1) -\u003e list:\n    lista_saida = [i+val for i in lista_entrada]\n    return lista_saida\n\nprint(soma_val([10, 11, 12]))\nprint(soma_val([10, 11, 12],3))\n```\n\n### Importação de bibliotecas\n\nAs funcionalidades do Python podem ser extendidas através da importação de bibliotecas. Por exemplo, a biblioteca NumPy permite operar com matrizes multidimensionais chamadas de `ndarrays`.\nPor exemplo:\n\n```python\nimport numpy\n\na = numpy.array([10, 11, 12])\nprint(type(a))\nprint(a)\n```\n\nPode-se também definir um nome abreviado para chamar as funções do pacote:\n\n```python\nimport numpy as np\n\na = np.array([10, 11, 12])\nprint(type(a))\nprint(a)\n```\n\nHá bibliotacas que são instalados em conjunto com o Python no computador, mas há outras que necessitam de ser instaladas antes da sua importação num programa. \nPor exemplo, se a biblioteca SymPy não estiver instalada é preciso primeiro fazer:\n```\n!pip install sympy\n```\nSe a biblioteca já estiver instalada, não há alteração.\n\n```python\n!pip install sympy\n```\n\n```python\nimport sympy as sp\n```\n\nA forma de utilizar estas bibliotecas será feita em notebooks separados.\n\n```python\n\n```\n","lastmodified":"2022-11-17T15:36:24.745381314Z","tags":null},"/jupyter/intro-numpy/intro-numpy":{"title":"","content":"\n# Introdução à Biblioteca NumPy\n\n_Luis Caldas de Oliveira_\n\nO NumPy é a biblioteca normalmente usada em Python quando se pretende realizar computação numérica de forma eficiente. Nesse caso a estrutura de dados mais comum é a matriz multi-dimensional.\n\n\n## Matrizes multi-dimensionais\n\nA classe `ndarray`, definida na biblioteca NumPy, permite realizar operações sobre matrizes de forma mais intuitiva e rápida do que se conseguiria com a classe `list` da versão de base do Python.\n\nEm listas a operação `+` faz a concatenação de duas listas e a `*` não tem significado:\n\n```python\na = [1,2,3]\nb = [4,5,6]\nprint(\"a+b:\", a+b)\ntry:\n    print(a*b)\nexcept TypeError:\n    print(\"A multiplicação de listas (a*b) não tem significado em Python\")\n```\n\nAs mesmas operações têm um significado diferente quando operam sobre a classe `ndarray`:\n\n```python\nimport numpy as np\n\na = np.array([1,2,3])\nb = np.array([4,5,6])\nprint(\"a+b:\", a+b)\nprint(\"a*b:\", a*b)\n```\n\nA classe `ndarray` tem também as característas esperadas de uma matriz multi-dimensional, nomeadamente os diferentes eixos. No caso de um matriz bi-dimensional, o primeiro eixo corresponde às linhas da matriz e o segundo às colunas\n\n```python\nmatriz2D = np.array([[1, 2], [3, 4]])\nprint(matriz2D)\nprint(\" \")\nprint(matriz2D[0])\nprint(\"matriz2D.sum(axis=0)=\", matriz2D.sum(axis=0))\nprint(\"matriz2D.sum(axis=1)=\", matriz2D.sum(axis=1))\n```\n\nPara uma matriz com 3 dimensões:\n\n```python\nmatriz3D = np.array([[[1, 2, 3], [4, 5, 6], [7, 8, 9]],\n                     [[1, 2, 3], [4, 5, 6], [7, 8, 9]],\n                     [[1, 2, 3], [4, 5, 6], [7, 8, 9]]])\nprint(matriz3D)\nprint(\" \")\nprint(matriz3D.sum(axis=0))\nprint(\" \")\nprint(matriz3D.sum(axis=1))\nprint(\" \")\nprint(matriz3D.sum(axis=2))\n```\n\nAs operações matriciais são fáceis de indicar:\n\n```python\nm1 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nm2 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nprint(m1+m2)\nprint(m1*m2)\n```\n\n## Funções para matrizes multi-dimensionais\n\nAo definir funções para processar matrizes multi-dimensionais é útil tornar patente que estas recebem e retornam objetos da classe `ndarray`.\n\n```python\ndef square(x: np.ndarray) -\u003e np.ndarray:\n    '''\n    Square each element in the input ndarray.\n    '''\n    return np.power(x, 2)\n\nmatriz = np.array([[1, 2], [3, 4]])\nprint(matriz)\nprint(square(matriz))\n```\n\n## Representação gráfica\n\nA biblioteca `matplotlib` pode ser usada para visualizar o conteúdo de vetores e matrizes.\n\nPara visualizar um vetor que tem amostras de uma função sinusoidal:\n\n```python\nimport matplotlib.pyplot as plt\n\nx = np.arange(-2*np.pi, 2*np.pi, 0.1)\ny = np.sin(x)\nplt.plot(x, y)\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.title(\"y = sin(x)\");\n```\n\nPara ter mais controlo sobre as figuras, o melhor é usada a abordagem dos objetos para criar um objeto figura que contém todo o gráfico.\n\n```python\n# O objeto fig vai conter todo o gráfico\nfig = plt.figure()\n# Divide o espaço da figura numa linha e numa coluna e usa a\n# primeira, divisão, ou seja, o gráfico vai ocupar todo o espaço\nax = fig.add_subplot(111)\n# junta coisas ao espaço ax\nax.plot(x, y)\nax.set_xlabel(\"x\")\nax.set_ylabel(\"y\")\nax.set_title(\"y = sin(x)\")\n```\n\nExiste uma coleção de [tutoriais para o matplotlib](https://matplotlib.org/stable/tutorials/index.html)\n","lastmodified":"2022-11-17T15:36:24.745381314Z","tags":null},"/jupyter/intro-sympy/intro-sympy":{"title":"","content":"\n## Instalação\n\nTal como outras bibliotecas para a linguagem Python, a SymPy pode ser instalado com o comando `pip`.\n\nPara usar funções SymPy num programa é preciso fazer a importação da biblioteca com a instrução `import`\n\n```python\n!pip install sympy\n\nimport sympy as sp\nprint(sp.__version__)\n```\n\n## Matemática Simbólica\n\nA biblioteca SymPy distingue-se da biblioteca de matemática normal do Python (math), por não realizar os cálculos quando estes dão um resultado aproximado. Por exemplo:\n\n```python\nimport math\nimport sympy\n\nprint(math.sqrt(12))\nprint(sympy.sqrt(12))\n```\n\nApesar de não apresentar o resultado numérico, a biblioteca SymPy simplifica-o sem perder precisão.\n\n\n## Formatação do Resultado\n\nPor omissão as expressões usadas na biblioteca SymPy são apresentada em forma de texto como no exemplo anterior.\n\nPode ser mais conveniente a utilização de um formatador dos resultados (_pretty-printer_) que os apresente na forma habitual de um equação matemática.\n\n```python\nimport sympy as sp\nsp.init_printing()\n\nsp.sqrt(12)\n```\n\nPara apresentar um resultado sem ser a saída do código Python, pode-se usar a função `display()` que se encarrega de apresentar o objeto na forma mais adequada.\n\n```python\ndisplay(sp.sqrt(12))\n```\n\nPode-se também usar uma das funções `print_xxx()` para apresentar o resultado em diferentes formatos.\n\n```python\nsp.print_latex(sp.sqrt(12))\nsp.print_python(sp.sqrt(12))\n```\n\n## Símbolos\n\nA classe `Symbol`é a mais importante em SymPy pois permite definer que uma cadeia de carateres representa um símbolo que pode ser atribuído a uma variável usando a função `symbol()`. Com essas variáveis é possível definir uma expressão simbólica\n\n```python\nx = sp.Symbol('x')\ny = sp.Symbol('y')\nexpr = x**2 + y**2\ndisplay(expr)\n```\n\nA função `symbols()` permite a atribuição de vários símbolos a várias variáveis.\n\n```python\nx,y,z = sp.symbols(\"x,y,z\")\nexpr = sp.sqrt(x**2 + y**2 + z**2)\ndisplay(expr)\n```\n\n## Expressões\n\nEm SymPy é possível manipular expressões algébricas.\n\n```python\nexpr = sp.sin(x)**2 + sp.cos(x)**2 \ndisplay(expr)\nexpr1 = expr.subs(x,y)\ndisplay(expr1)\n```\n\nO método `subs()` também é útil para avaliar a expressão para um valor\n\n```python\nexpr_pi = expr.subs(x,sp.pi)\ndisplay(expr_pi)\n```\n\nA função `sympify()` converte uma cadeia de carateres contendo uma expressão matemática, numa expressão que pode ser manipulada pela SymPy.\n\n```python\nexpr = sp.sympify(\"x**2+3*x+2\")\ndisplay(expr)\ndisplay(expr.subs(x,3))\n```\n\nUma expressão em SymPy pode ser convertida numa função Python com a função `lambdify()`. A função resultante converte os nomes SymPY para os de uma biblioteca numérica, normalmente o NumPy.\n\n```python\nexpr = 1/sp.sin(x)\nf = sp.lambdify(x, expr)\nprint(f(3.14))\n```\n\nPara especificar o uso do NumPy:\n\n```python\nimport numpy as np\nexpr = x**2\nf = sp.lambdify(x , expr, \"numpy\")\nprint(f(np.arange(1,6)))\n```\n\n## Simplificação de Expressões\n\nUma das facilidades mais importantes da biblioteca SymPy é a simplificação de expressões algébricas com a função `simplify()`.\n\n```python\nx = sp.Symbol('x')\nexpr = sp.sin(x)**2 + sp.cos(x)**2\ndisplay(expr, sp.simplify(expr))\n```\n\nOutra facilidade da SymPy é a expansão de expressões polinomiais com a função `expand()`. \n\n```python\na,b = sp.symbols('a b')\nexpr = (a + b) ** 2\ndisplay(expr, sp.expand(expr))\n```\n\nÉ também possível fatorizar um polinómio\n\n```python\nx,y,z = sp.symbols('x y z') \nexpr = x**2*z + 4*x*y*z + 4*y**2*z\ndisplay(expr, sp.factor(expr))\nprint(' ')\nexpr = a**2 + 2*a*b + b**2\ndisplay(expr, sp.factor(expr))\n```\n\nA função `collect()` junta termos aditivos de uma expressão com respeito a potências de expoente racional de uma variável ou expressão.\n\n```python\nexpr = x*y + x - 3 + 2*x**2 - z*x**2 + x**3\ndisplay(expr, sp.collect(expr,x))\n```\n\nA função `cancel()` simplifica funções racionais e converte-as na forma canónica $p/q$ em que $p$ e $q$ são polinómios sem fatores comuns.\n\n```python\nnumer = x**2 + 2*x + 1\ndenom = x + 1\ndisplay(numer/denom, sp.cancel(numer/denom))\n```\n\n## Derivadas e Integrais\n\nA biblioteca SymPy inclui a função `diff()` que calcula a expressão algébrica que é a derivada de outra expressão. Para calcular\n$$\ny' = \\frac{d}{dx} \\left( x sin(x^2) + 1 \\right)\n$$\n\n```python\nexpr = x * sp.sin(x**2) + 1\ndisplay(sp.diff(expr, x))\n```\n\nA função `integrate()` faz a operação inversa, ou seja, calcula o integral da expressão.\n$$\ny = \\int ( x^2 + x + 1) dx\n$$\n\n```python\nexpr = x**2 + x + 1\ndisplay(sp.integrate(expr, x))\n```\n\nÉ também possível calcular integrais definidos, por exemplo\n$$\ny = \\int_0^\\infty e^{-x^2} dx\n$$\n\n```python\nexpr = sp.exp(-x**2)\ndisplay(sp.integrate(expr,(x,0,sp.oo)))\n```\n\n## Números Complexos\n\nA biblioteca SymPy tem um conjunto de funções para manipular expressões com números complexos. Para definir a parte complexa de um número usa-se o símbolo `I`.\n\n```python\nz = sp.Symbol('z', complex=True)\nexpr = sp.exp(z)\ndisplay(expr)\ndisplay(expr.subs(z,sp.I * sp.pi/2))\n```\n\nAlgumas funções\n\n```python\nz = sp.Symbol('z', complex=True)\nexpr_z = sp.exp(z)\n\ndisplay(expr_z)\n\ndisplay(sp.re(expr_z)) # parte real\ndisplay(sp.im(expr_z)) # parte imaginária\ndisplay(sp.Abs(expr_z)) # módulo\ndisplay(sp.arg(expr_z)) # fase\ndisplay(sp.conjugate(expr_z)) # conjugado\n```\n\n## Gráficos\n\nO SymPy permite visualizar gráficos de funções\n\n```python\nexpr = 2*x**2 + 2*x -4\ndisplay(expr)\ndisplay(sp.plot(expr))\n```\n\n## Resolução de Equações\n\nA biblioteca SymPy inclui a função `solve()` para determinar os zeros de uma função. \n\n```python\nexpr = 8*x**2 + 2*x + 4\ndisplay(expr)\ndisplay(sp.solve(expr))\n```\n\nA função `solve()` pode também ser usada para resolver sistemas de equações:\n\n```python\nx, y = sp.symbols('x, y')\nsist = [x + y - 2, x - y - 0]\ndisplay(sist)\nsol = sp.solve(sist, [x, y])\ndisplay(sol)\nprint('x =', sol[x], 'y =', sol[y]) # sol é um dicionário\n```\n","lastmodified":"2022-11-17T15:36:24.745381314Z","tags":null},"/jupyter/problemas-cap1/problemas-cap1":{"title":"","content":"\n# Problemas Cap. 1\n\n_Luis Caldas de Oliveira_\n\n\n\n\n## Problema 1.21\n\n[[Sec-1.2 Transformação da variável independente (tvi)]]\n\nConsidere o sinal em tempo contínuo $x(t)$ definida por ramos (_picewise_):\n\n$$\nx(t) = \n\\begin{cases} 0 \u0026 \\text{para}\\: t \u003c -2 \\\\t + 1 \u0026 \\text{para}\\: t \u003e -2 \\wedge t \u003c -1 \\\\1 \u0026 \\text{para}\\: t \u003e -1 \\wedge t \u003c 0 \\\\2 \u0026 \\text{para}\\: t \u003e 0 \\wedge t \u003c 1 \\\\2 - t \u0026 \\text{para}\\: t \u003e 1 \\wedge t \u003c 2 \\\\0 \u0026 \\text{para}\\: t \u003e 2 \\end{cases}\n$$\n\nDesenhe cuidadosamente cada um dos seguintes sinais.\n\n(a) $x(t-1)$\n\n(b) $x(2-t)$\n\n(c) $x(2t+1)$\n\n(d) $x(4-\\frac{t}{2})$\n\n(e) $[x(t) + x(-t)] u(t)$\n\n(f) $x(t)\\left[\\delta(t+\\frac{3}{2})-\\delta(t-\\frac{3}{2})\\right]$\n\n\n\n```python\nimport sympy as sp\nt = sp.Symbol('t', real=True)\nxt = sp.Piecewise((0, t\u003c-2),\n                  (t+1, (t\u003e-2) \u0026 (t\u003c-1)),\n                  (1, (t\u003e-1) \u0026 (t\u003c0)),\n                  (2, (t\u003e0) \u0026 (t\u003c1)),\n                  (-t+2, (t\u003e1) \u0026 (t\u003c2)),\n                  (0, t\u003e2))\n# sp.print_latex(xt)\n\nprint('x(t)')\np0 = sp.plot(xt, (t, -3, 5), xlabel='', ylabel='', show=False)\np0.save('fig-p-1-21.svg')\np0.show()\n```\n\n```python\nprint('(a) x(t-1)')\nxta = xt.subs(t, t-1)\np1 = sp.plot(xta, (t, -3, 5), xlabel='', ylabel='', show=False)\n\nprint('x(t)')\np0.show()\nprint('x(t-1)')\np1.save('fig-p-1-21-a.svg')\np1.show()\n```\n\n```python\nprint('(b) x(2-t)')\nx1t = xt.subs(t, -t)\np1 = sp.plot(x1t, (t, -3, 5), xlabel='', ylabel='', show=False)\nx2t = xt.subs(t, 2-t)\np2 = sp.plot(x2t, (t, -3, 5), xlabel='', ylabel='', show=False)\n\nprint('x(t)')\np0.show()\nprint('x1(t) = x(-t)')\np1.save('fig-p-1-21-b-x1.svg')\np1.show()\nprint('x2(t) = x1(t-2) = x(2-t)')\np2.save('fig-p-1-21-b.svg')\np2.show()\n```\n\n```python\nprint('(c) x(2t+1)')\nx1t = xt.subs(t, 2*t)\np1 = sp.plot(x1t, (t, -3, 5), xlabel='', ylabel='', show=False)\nx2t = xt.subs(t, 2*t+1)\np2 = sp.plot(x2t, (t, -3, 5), xlabel='', ylabel='', show=False)\n\nprint('x(t)')\np0.show()\nprint('x1(t) = x(2t)')\np1.save('fig-p-1-21-c-x1.svg')\np1.show()\nprint('x2(t) = x1(t+1/2) = x(2t+1)')\np2.save('fig-p-1-21-c.svg')\np2.show()\n```\n\n```python\nprint('(d) x(4-t/2)')\np0 = sp.plot(xt, (t, -4, 13), xlim=(-4, 13), xlabel='', ylabel='', show=False)\nx1t = xt.subs(t, -t/2)\np1 = sp.plot(x1t, (t, -4, 13), xlim=(-4, 13), xlabel='', ylabel='', show=False)\nx2t = xt.subs(t, 4-t/2)\np2 = sp.plot(x2t, (t, -4, 13), xlim=(-4, 13), xlabel='', ylabel='', show=False)\n\nprint('x(t)')\np0.show()\nprint('x1(t) = x(-t/2)')\np1.save('fig-p-1-21-d-x1.svg')\np1.show()\nprint('x2(t) = x1(t-8) = x(4-t/2)')\np2.save('fig-p-1-21-d.svg')\np2.show()\n```\n\n```python\nprint('(e) (x(t) + x(-t)) u(t)')\nU = sp.Lambda(t, (sp.sign(t)+1)/2)\n\np0 = sp.plot(xt, (t, -3, 5), xlabel='', ylabel='', show=False)\nx1t = (xt + xt.subs(t, -t))\np1 = sp.plot(x1t, (t, -3, 5), xlabel='', ylabel='', show=False)\nx2t = (xt + xt.subs(t, -t)) * U(t)\np2 = sp.plot(x2t, (t, -3, 5), xlabel='', ylabel='', show=False)\n\nprint('x(t)')\np0.show()\nprint('x1(t) = x(t) + x(-t)')\np1.save('fig-p-1-21-e-x1.svg')\np1.show()\nprint('x2(t) = x1(t) u(t) = (x(t) + x(-t)) u(t)')\np2.save('fig-p-1-21-e.svg')\np2.show()\n```\n\n```python\nprint('(f) x(t) (\\delta(t+3/2)) - \\delta(t-3/2))')\n\nx1t = xt.subs(t,-3/2) * sp.DiracDelta(t+3/2) - xt.subs(t,3/2) * sp.DiracDelta(t-3/2)\n\nsp.init_printing()\ndisplay(x1t)\n```\n\n## Problema 1.22\n\n[[Sec-1.2 Transformação da variável independente (tvi)]]\n\nPágina 59 do livro guia\n\nConsidere o seguinte sinal em tempo discreto $x(n)$ :\n\nDesenhe cuidadosamente cada um dos seguintes sinais.\n\n(a) $x(n-4)$\n\n(b) $x(3-tn)$\n\n(c) $x(3n)$\n\n(d) $x(3n+1)$\n\n(e) $x(n) u(3-n)$\n\n(f) $x(n-2)\\delta(n-2)$\n\n(g) $\\frac{1}{2} x(n) + \\frac{1}{2} (-1)^n x(n)$\n\n(h) $x((n-1)^2)$\n\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\nn = np.arange(-5,5)\nx = np.array([0, -1, -1/2, 1/2, 1, 1, 1, 1, 1/2, 0])\n\nplt.figure(figsize=(6, 3))\nplt.stem(n, x)\nplt.xlabel('$n$')\nplt.ylabel('$x(n)$')\nplt.gca().margins(y=0.1)\n```\n\n```python\nimport numpy as np\nimport matplotlib\nimport matplotlib.pyplot as plt\n\ndef PlotDSignal(var: np.array, signal: np.array, name: str) -\u003e None:\n    plt.figure(figsize=(7, 3))\n    plt.stem(var, signal, markerfmt='o',basefmt='black')\n    plt.xticks(np.arange(min(n), max(n)+1, 1.0))\n    plt.gca().margins(y=0.15)\n    plt.grid()\n    plt.ylabel('$'+name+'$')\n    return\n\ndef x(n: np.array) -\u003e np.array:\n\treturn np.piecewise(n.astype(float), [n\u003c-4, ((n\u003e=-4) \u0026 (n\u003c0)), ((n\u003e=0) \u0026 (n\u003c3)), (n==3), (n\u003e=4)], [0, lambda n: 0.5*n+1.5, 1, 0.5, 0])\n\nn = np.arange(-7,10)\n\nprint('(a)  ya(n)=x(n-4)')\nstc = PlotDSignal(n, x(n), 'x(n)')\nprint(type(st))\nplt.savefig('teste' + '.svg')\nplt.show()\n\nPlotDSignal(n, x(n-4), 'y_a(n)=x(n-4)')\nplt.show()\n\n```\n\n```python\n\n```\n","lastmodified":"2022-11-17T15:36:24.75338142Z","tags":null},"/jupyter/sinais-cont-disc/sinais-cont-disc":{"title":"","content":"\n# Sinais em tempo contínuo e tempo discreto\n\n_Luis Caldas de Oliveira_\n\nEste notebook apresenta a forma de representar sinais em Python usando as bibliotecas SymPy para sinais contínuos e NumPy para sinais discretos\n\n\n## Sinais em tempo contínuo\n\nApesar de, em certas condições, os sinais em tempo contínuo poderem ser representados em tempo discreto sem perda de informação, o tratamento geral desses sinais deve ser feito com matemática simbólica.\n\n### Matemática simbólica em Python\n\nO Python dispõem de um biblioteca de matemática simbólica chamada de SymPy que iremos usar ao longo deste curso. \n\nTal como outras bibliotecas para a linguagem Python, a SymPy pode ser instalado com o comando `pip`.\nPara usar funções SymPy num programa é preciso fazer a importação da biblioteca com a instrução `import`\n\n```python\n!pip install sympy\n\nimport sympy as sp\nsp.init_printing()\n\nfrom IPython.display import display, Math\n\nprint(sp.__version__)\n```\n\nA biblioteca SymPy distingue-se da biblioteca de matemática normal do Python (math), por não realizar os cálculos quando estes dão um resultado aproximado. Apesar de não apresentar o resultado numérico, a biblioteca SymPy simplifica-o sem perder precisão.\n\n```python\nimport math \n\ndisplay(math.sqrt(12))\ndisplay(sp.sqrt(12))\n```\n\nPodemos definir uma expressão que represente uma função matemática em SymPy se primeiro definirmos como símbolos as variáveis dependentes\n\n```python\nomega, t = sp.symbols('\\omega, t', real=True)\nfunc = sp.sin(omega * t)\ndisplay(func)\n```\n\nPara a avaliar a função faz-se a substituição da variável independente pelos valores que queremos. Neste caso $\\omega = \\pi / 2$ e $t=1$:\n\n```python\ndisplay(func.subs([(omega, sp.pi/2), (t, 1)]))\n```\n\n## Representação de sinal em tempo contínuo em SymPy\n\nUm sinal $x_c(t)$ em tempo contínuo é uma função de uma variável contínua.\n$$\n\\forall t \\in \\mathbb{R}, x(t) = \\ldots\n$$\nna forma de uma [[função matemática]]:\n$$\n x: \\mathbb{R} \\rightarrow \\mathbb{R}\n$$\n\nUsando a biblioteca SymPy podemos representar um tom puro em tempo contínuo\n$$\\forall t \\in \\mathbb{R}, x(t) = \\sin(2 \\pi \\times 440 t)$$\n$$x: \\mathbb{R} \\rightarrow [-1,1] $$\n\nNa forma\n\n```python\nt = sp.symbols('t', real=True)\nxc = sp.sin(2 * sp.pi * 440 * t)\ndisplay(Math('x_c(t) = ' + sp.latex(func)))\n```\n\nPodemos visualizar graficamente o sinal em tempo contínuo $x_c(t)$ para $t \\in [-4 ms, 4 ms]$ \n\n\n```python\nplt=sp.plot(xc, (t,-.004,0.004),ylabel='')\n```\n\n## Sinais em tempo discreto\n\nOs sinais em tempo discreto podem ser representados com matrizes multidimensionais. Faz por isso sentido usarmos a biblioteca NumPy do Python para os representar\n\n\n### Matrizes multidimensionais em Python\n\nO NumPy é a biblioteca normalmente usada em Python quando se pretende realizar computação numérica de forma eficiente onde a estrutura de dados mais comum é a matriz multi-dimensional.\n\nA classe `ndarray`, definida na biblioteca NumPy, permite realizar operações sobre matrizes de forma mais intuitiva e rápida do que se conseguiria, por exemplo, com a classe `list` da versão de base do Python.\n\nO Numpy vem instalado por omissão na maioria das distribuições do Python, pelo que basta importar a biblioteca.\n\n```python\nimport numpy as np\n\na = np.array([1,2,3])\nb = np.array([4,5,6])\nprint(\"a+b:\", a+b)\nprint(\"a*b:\", a*b)\n```\n\nAs matrizes podem ter um número variável de dimensões e por isso podem funcionar como funções em que o domínio é $\\mathbb{N}_0^D$. Para uma matriz tri-dimensional com $3 \\times 3 \\times 3$:\n\n$$ m_{3D}: \\{0, 1, 2\\}^{3} \\rightarrow \\mathbb{R} $$\n\n```python\nm3D = np.array([[[1, 2, 3], [4, 5, 6], [7, 8, 9]],\n                [[5, 6, 7], [8, 9, 10], [11, 12, 13]],\n                [[14, 15, 16], [17, 18, 19], [20, 21, 22]]])\nprint(\"m3D[0,0,0] = \", m3D[0,0,0])\nprint(\"m3D[2,2,2] = \", m3D[2,2,2])\n```\n\n### Representação de um sinal em tempo discreto em NumPy\n\nAo contrário do SymPy para os sinais em tempo contínuo, as matrizes do NumPy não permite a representação de sinais de duração infinita. Vimos também que os índices das matrizes começam sempre em zero.\n\nA forma de resolver esta limitação vamos considerar o sinal em tempo discreto $x_d(n)$:\n$$ x_d: \\mathbb{Z} \\rightarrow \\mathbb{R}$$\n\nDefinido pela expressão:\n$$ x_d(n) = \\sin\\left(\\frac{2 \\pi}{30} n\\right)$$\n\nPara representar este sinal usamos dois vetores. O vetor `n` contém o segmento do sinal que queremos tratar enquanto o vetor `xd` contém o valor do sinal nesse ponto.\n\n\n```python\nn = np.arange(-30,30)\nxd = np.sin(2 * np.pi * n / 30)\nprint('n =', n[0:3])\nprint('xd(n) =', xd[0:3])\n```\n\nCom a facilidade do NumPy operar com vetores a forma mais eficaz de representar um sinal é a de definir uma função que recebe como entrada o vetor com as amostras desejadas do sinal, retornando o seu valor\n\n```python\ndef xd(n: np.array) -\u003e np.array:\n    return np.sin(2 * np.pi * n / 30)\n\nprint('xd(-30) =', xd(-30))\n```\n\nPara visualizar o sinal em tempo discreto usamos a função `stem` da biblioteca matplotlib\n\n```python\nimport matplotlib.pyplot as plt\n\nn = np.arange(-5,31)\nplt.stem(n, xd(n))\n```\n\n### Leitura de ficheiro wav\n\nO format _wav_ é uma norma para guardar num ficheiro um sinal em tempo discreto.\n\nA biblioteca SciPy tem uma função para ler esse formato de ficheiros\n\n```python\nfrom scipy.io import wavfile\nimport matplotlib.pyplot as plt\n\nfs, s = wavfile.read('../../attachments/Sine_wave_440.wav')\n\nn = np.arange(0,300)\nplt.plot(n, s[n])\n```\n\n### Reproduzir um sinal de audio\n\n\n\n```python\nfrom IPython.display import Audio\nAudio(data=s, rate=fs)\n\n\n```\n\n### Gravar um sinal de audio\n\n\n\n```python\n\n!pip install gradio -q\n\n\n```\n\n```python\nimport gradio as gr \nimport time\n```\n\n```python\ndef save(audio):\n    wavfile.write('file.wav', audio)\n    return 'file saved'\n```\n\n```python\ngr.Interface(\n    title = 'OpenAI Whisper ASR Gradio Web UI', \n    fn=save, \n    inputs=[\n        gr.inputs.Audio(source=\"microphone\", type=\"filepath\")\n    ],\n    outputs=[\n        \"textbox\"\n    ],\n    live=True).launch()\n```\n\n```python\n\n```\n","lastmodified":"2022-11-17T15:36:24.765381579Z","tags":null},"/jupyter/transf-var-ind/transf-var-ind":{"title":"","content":"\n# Transformação da variável independente\n\n_Luis Caldas de Oliveira_\n\nNeste notebook apresenta-se a forma de implementar a transformação da variável independente usando o SympPy (sinais em tempo contínuo) e o NumPy (sinais em tempo discreto)\n\n\n## Sinais em tempo contínuo\n\nPara operar com sinais em tempo contínuo começamos por importar biblioteca SymPy e definir a impressão dos resultados do código na forma de equações matemáticas. Definimos também a variável $t \\in \\mathbb{R}$\n\n```python\nimport sympy as sym\nsym.init_printing()\n\nt = sym.symbols('t', real=True)\n```\n\nDefinimos uma função para apresentar os gráficos\n\n```python\ndef PlotSignal(var: sym.core.symbol.Symbol, signal: sym.Piecewise, name: str) -\u003e None:\n    splt = sym.plot(signal, (t, -3, 5), xlabel='',\n              ylim=[-0.1, 0.6], ylabel='', line_color=\"red\",\n              show=False)\n    #splt.save(name + '.svg')\n    print(name)\n    splt.show()\n    return\n```\n\n### Sinal de exemplo\n\nSeguidamente vamos criar um sinal de exemplo. Vamos escolher um sinal de duração limitada que definimos por troços.\n$$\nx(t) =\n\\begin{cases}\n0 \u0026 \\text{para}\\: t \u003c 0 \\\\\nt \u0026 \\text{para}\\: t \\ge 0 \\land t \u003c 1/2 \\\\\n(2 - t)/3 \u0026 \\text{para}\\: t \\ge 1/2 \\land t \u003c 2 \\\\\n0 \u0026 \\text{para}\\: t \\ge 2\n\\end{cases}\n$$\n\n```python\nx = sym.Piecewise((0, t\u003c0),\n                 (t, (t\u003e=0) \u0026 (t\u003c1/2)),\n                 ((2-t)/3, (t\u003e=1/2) \u0026 (t\u003c2)),\n                 (0, t\u003e=2))\n\nPlotSignal(t, x, 'x(t)')\n```\n\n### Deslocamento temporal\n\nO deslocamento temporal de um sinal em tempo contínuo $x(t)$ define-se como:\n$$ y(t) = x(t-t_0), \\;\\; t_0 \\in \\mathbb{R}$$\n\nSe $t_0 \u003e 0$ o gráfico do sinal desloca-se para a direita.\n\nO método `.subs()` da biblioteca SymPy faz a tranformação da variável independente.\n\n```python\nt0 = 1\ny = x.subs(t, t-t0)\n\nPlotSignal(t, y, 'y(t)=x(t-t0)')\n```\n\n### Escalamento temporal\n\nO escalmento temporal de um sinal em tempo contínuo $x(t)$ define-se como:\n$$ y(t) = x(at), \\;\\; a \\in \\mathbb{R}$$\n\nSe $a \\in ]0, 1[$ o gráfico do sinal alarga-se.\n\n```python\na= 1/2\ny = x.subs(t, a*t)\n\nPlotSignal(t, y, 'y(t)=x(a*t)')\n```\n\n### Inversão temporal\n\nA inversão temporal é um caso particular do escalamento temporal quando o fator de escalamento é negativo, por exemplo:\n$$ y(t) = x(-t)$$\n\n\n```python\na= -1\ny = x.subs(t, a*t)\n\nPlotSignal(t, y, 'y(t)=x(-t)')\n```\n\n### Composição de transformações\n\nNo caso geral de uma transformação linear da variável independente:\n$$ y(t) = x(at-t_0)$$\n\nA resolução manual é mais facilmente realizada por partes.\nComeça-se pelo escalamento:\n$$ x_1(t) = x(at)$$\nseguindo-se o deslocamento\n$$ y(t) = x_1(t-t_0/a) = x(at - t_0)$$\n\nNo entanto, com o SymPy a transformação pode ser feita de uma vez. Por exemplo:\n$$ y(t) = x(-2t+6)$$\n\n\n```python\na= -2\nt0 = -6\n\nx1 = x.subs(t, a*t)\nPlotSignal(t, x1, 'x1(t)=x(%d*t)'%(a))\n\ny = x.subs(t, a*t-t0)\nPlotSignal(t, y, 'y(t)=x1(t%+d))=x(%d*t%+d)'%(-t0/a, a, -t0))\n```\n\n## Sinais em tempo discreto\n\nPara operar com sinais em tempo contínuo começamos por importar biblioteca NumPy e a biblioteca gráfica matplotlib.\n\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\n%matplotlib inline\n```\n\nFunção para desenhar os gráficos.\n\n```python\ndef PlotDSignal(var: np.array, signal: np.array, name: str) -\u003e None:\n    plt.figure(figsize=(7, 3))\n    plt.stem(var, signal, markerfmt='o',basefmt='black')\n    plt.xticks(np.arange(min(n), max(n)+1, 1.0))\n    plt.gca().margins(y=0.15)\n    plt.grid()\n    plt.xlabel('$n$')\n    plt.ylabel('$'+name+'$')\n    plt.show()\n    return\n```\n\n### Sinal de exemplo\n\nTal como em tempo contínuo, vamos criar um sinal de duração limitada que definimos por troços:\n$$\nx(n) =\n\\begin{cases}\n0 \u0026 \\text{para}\\: n \u003c 0 \\\\\n2 \u0026 \\text{para}\\: n \\ge 0 \\land n \u003c 3 \\\\\n4 \u0026 \\text{para}\\: n \\ge 3 \\land n \u003c 6 \\\\\n0 \u0026 \\text{para}\\: n \\ge 6\n\\end{cases}\n$$\n\nem que $n \\in \\mathbb{Z}$.\n\nO sinal é definido como uma função\n\n```python\ndef xd(n: np.array) -\u003e np.array:\n    xd = np.piecewise(n,\n                      [n\u003c0, (n\u003e=0)\u0026(n\u003c3), (n\u003e=3)\u0026(n\u003c6), n\u003e=6], \n                      [0, 2, 4, 0])\n    return xd\n```\n\nVamos avaliar o sinal num intervalo limitado de valores no intervalo:\n$$\nn \\in \\{n_s, \\ldots, n_s + N\\}\n$$\n\n```python\nn = np.arange(-5, 13)\nPlotDSignal(n, xd(n), 'x(n)')\n```\n\n### Deslocamento temporal\n\nO deslocamento temporal de um sinal em tempo discreto $x(n)$ define-se como:\n$$ y(n) = x(n-n_0), \\;\\; n_0 \\in \\mathbb{Z}$$\n\nSe $n_0 \u003e 0$ o gráfico do sinal desloca-se para a direita.\n\n\n```python\nn0 = 5\nPlotDSignal(n, xd(n-n0), 'y(n)=x(n%+g)'%(-n0))\n```\n\n### Escalamento temporal\n\nO escalamento temporal de um sinal em tempo discreto $x(n)$ define-se como:\n$$ y(n) = x(a n), \\;\\; a \\in \\mathbb{R}$$\n\n\n```python\na=1/2\nPlotDSignal(n, xd(a*n), 'y(n)=x(%gn)'%a)\n```\n\n### Composição de transformações\n\nNo caso geral de uma transformação linear da variável independente:\n$$ y(n) = x(an-n_0)$$\n\nA resolução manual é mais facilmente realizada por partes.\nComeça-se pelo escalamento:\n$$ x_1(n) = x(an)$$\nseguindo-se o deslocamento\n$$ y(n) = x_1(n-n_0/a) = x(an - n_0)$$\n\nNo entanto, com o SymPy a transformação pode ser feita de uma vez. Por exemplo:\n$$ y(n) = x(-2n+6)$$\n\n```python\na = -2\nn0 = -6\n\nPlotDSignal(n, xd(a*n), 'x_1(n)=x(%gn)'%a)\n\nPlotDSignal(n, xd(a*n-n0), 'y(n)=x_1(n%+g)=x(%gn%+g)'%(-n0/a, a, -n0))\n\n```\n\n```python\n\n```\n\n```python\n\n```\n","lastmodified":"2022-11-17T15:36:24.769381632Z","tags":null},"/topicos/1-1-Sinais-em-tempo-cont%C3%ADnuo-e-em-tempo-discreto":{"title":"1.1 Sinais em tempo contínuo e em tempo discreto","content":"\nNesta secção define-se um sinal como uma função matemática cuja variável independente representa um elemento do seu domínio. Como muitos sinais representam grandezas que variam no tempo, dividimos os sinais em duas classes: os em que a variável independente toma valores reais (sinais em tempo contínuo) e os em que a variável toma valores inteiros (sinais em tempo discreto). Um [sinal acústico](../aula01/ss-sin/sinal%20acústico.md) é um exemplo de um [sinal em tempo contínuo](../aula01/ss-sin/sinal%20em%20tempo%20contínuo.md).\n\n## Novos conceitos\n- [sinal acústico](aulas/aula01/ss-sin-conc/sinal%20acústico.md)\n- [função matemática](aulas/aula01/ss-sin-conc/função%20matemática.md)\n- [conjunto de números](aulas/aula01/ss-sin-conc/conjunto%20de%20números.md)\n- [sinal em tempo contínuo](aulas/aula01/ss-sin-conc/sinal%20em%20tempo%20contínuo.md)\n- [tom puro em tempo contínuo](aulas/aula01/ss-sin-conc/tom%20puro%20em%20tempo%20contínuo.md)\n- [sinal bi-dimensional](aulas/aula01/ss-sin-conc/sinal%20bi-dimensional.md)\n- [sinal em tempo discreto](aulas/aula01/ss-sin-conc/sinal%20em%20tempo%20discreto.md)\n- [valor de fecho de índice de bolsa](aulas/aula01/ss-sin-conc/valor%20de%20fecho%20de%20índice%20de%20bolsa.md)\n- [imagem digital](aulas/aula01/ss-sin-conc/imagem%20digital.md)\n- [video digital](aulas/aula01/ss-sin-conc/video%20digital.md)\n- [amostragem de um sinal em tempo contínuo](aulas/aula01/ss-sin-conc/amostragem%20de%20um%20sinal%20em%20tempo%20contínuo.md)\n- [período de amostragem](aulas/aula01/ss-sin-conc/período%20de%20amostragem.md)\n- [ritmo ou frequência de amostragem](aulas/aula01/ss-sin-conc/ritmo%20ou%20frequência%20de%20amostragem.md)\n- [tom puro em tempo discreto](aulas/aula01/ss-sin-conc/tom%20puro%20em%20tempo%20discreto.md)\n- [codificação da amplitude](aulas/aula01/ss-sin-conc/codificação%20da%20amplitude.md)\n- [energia de um sinal](aulas/aula01/ss-sin-conc/energia%20de%20um%20sinal.md)\n- [potência de um sinal](aulas/aula01/ss-sin-conc/potência%20de%20um%20sinal.md)\n\n\nPróximo: [1-2 Transformação da variável independente](topicos/1-2%20Transformação%20da%20variável%20independente.md)","lastmodified":"2022-11-17T15:36:24.769381632Z","tags":null},"/topicos/1-2-Transforma%C3%A7%C3%A3o-da-vari%C3%A1vel-independente":{"title":"1.2 Transformação da variável independente","content":"\n\nNa secção anterior apresentou-se a representação de um sinal como uma função matemática. Iremos agora ver os efeitos da transformação da variável independente na representação de um sinal.\n\nTal como na secção anterior iremos considerar sinais que representam grandezas que variam no tempo, pelo que a transformação da variável independente corresponde a mudanças na escala temporal.\n\n## Novos conceitos\n- [deslocamento temporal em tempo contínuo](aulas/aula01/ss-tvi-conc/deslocamento%20temporal%20em%20tempo%20contínuo.md)\n- [inversão temporal](aulas/aula01/ss-tvi-conc/inversão%20temporal.md)\n- [escalamento temporal](aulas/aula01/ss-tvi-conc/escalamento%20temporal.md)\n- [sinais pares e ímpares](aulas/aula01/ss-tvi-conc/sinais%20pares%20e%20ímpares.md)\n- [componente par e ímpar de um sinal](aulas/aula01/ss-tvi-conc/componente%20par%20e%20ímpar%20de%20um%20sinal.md)\n\nPróximo: [deslocamento temporal em tempo contínuo](aulas/aula01/ss-tvi-conc/deslocamento%20temporal%20em%20tempo%20contínuo.md)\n","lastmodified":"2022-11-17T15:36:24.769381632Z","tags":null},"/topicos/1-Sinais-e-Sistemas":{"title":"1. Sinais e Sistemas","content":"","lastmodified":"2022-11-17T15:36:24.769381632Z","tags":null}}